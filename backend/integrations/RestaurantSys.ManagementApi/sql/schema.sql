-- ===== Core =====
SET search_path = public;
CREATE EXTENSION IF NOT EXISTS pgcrypto;  -- for gen_random_uuid()


-- ===== Tables =====

/* Menues */
CREATE TABLE IF NOT EXISTS menus (
  menu_num   INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name       TEXT NOT NULL CHECK (length(btrim(name)) > 0),
  created_at timestamptz NOT NULL DEFAULT now()
);

INSERT INTO menus (menu_num, name, created_at)
  VALUES (0, 'Default Menu', now())
  ON CONFLICT (menu_num) DO NOTHING;

CREATE TABLE IF NOT EXISTS menu_nodes (
  node_id     uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  parent_id   uuid NULL REFERENCES menu_nodes(node_id) ON DELETE CASCADE,
  name        TEXT NOT NULL CHECK (length(btrim(name)) > 0),
  is_leaf     boolean NOT NULL,
  price_cents int,
  sort_order  int NOT NULL DEFAULT 0,
  layer       int NOT NULL DEFAULT 0,          -- 0 = root
  menu_num    integer NOT NULL REFERENCES menus(menu_num),
  created_at  timestamptz NOT NULL DEFAULT now()
);

-- One root per menu
CREATE UNIQUE INDEX IF NOT EXISTS ux_menu_root_one_per_menu
  ON menu_nodes(menu_num)
  WHERE layer = 0 AND parent_id IS NULL;

CREATE INDEX IF NOT EXISTS ix_menu_nodes_parent      ON menu_nodes(parent_id);
CREATE INDEX IF NOT EXISTS ix_menu_nodes_menu        ON menu_nodes(menu_num);
CREATE INDEX IF NOT EXISTS ix_menu_nodes_parent_sort ON menu_nodes(parent_id, sort_order);
CREATE INDEX IF NOT EXISTS ix_menu_nodes_is_leaf     ON menu_nodes(is_leaf);

/* Ingredients */
CREATE TABLE IF NOT EXISTS ingredients (
  ingredient_id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name          text NOT NULL UNIQUE CHECK (length(btrim(name)) > 0),
  created_at    timestamptz NOT NULL DEFAULT now()
);

/* Products */
CREATE TABLE IF NOT EXISTS products (
  product_id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  menu_node_id        uuid REFERENCES menu_nodes(node_id) ON DELETE CASCADE,
  name                text NOT NULL CHECK (length(btrim(name)) > 0),
  type                text NOT NULL CHECK (length(btrim(type)) > 0),
  sold_as_bottle_only boolean NOT NULL DEFAULT FALSE,
  created_at          timestamptz NOT NULL DEFAULT now()
);

/* Products recipe line */
CREATE TABLE IF NOT EXISTS product_ingredients (
  product_id    uuid NOT NULL REFERENCES products(product_id)   ON DELETE CASCADE,
  ingredient_id uuid NOT NULL REFERENCES ingredients(ingredient_id) ON DELETE RESTRICT,
  changeable    boolean NOT NULL DEFAULT FALSE,
  is_leading    boolean NOT NULL DEFAULT FALSE,
  PRIMARY KEY (product_id, ingredient_id)
);

create table if not exists product_menu_nodes (
  product_id   uuid not null references products(product_id) on delete cascade,
  menu_node_id uuid not null references menu_nodes(node_id)  on delete cascade,
  primary key (product_id, menu_node_id)
);

create index if not exists ix_pmn_node    on product_menu_nodes(menu_node_id);
create index if not exists ix_pmn_product on product_menu_nodes(product_id);

/* Pricebook */
create table if not exists product_prices (
  product_id uuid NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
  menu_num   integer NOT NULL REFERENCES menus(menu_num) ON DELETE CASCADE,
  price      numeric(12,2) NULL,
  PRIMARY KEY (product_id, menu_num)
);

CREATE INDEX IF NOT EXISTS ix_products_node ON products(menu_node_id);          /* Products ix by id */
CREATE INDEX IF NOT EXISTS ix_products_name ON products((lower(name)));         /* Products ix by name */ 
CREATE INDEX IF NOT EXISTS ix_ingredients_name ON ingredients((lower(name)));   /* Ingredients */

/* MANAGEMENT SETTINGS (singleton) */
create table if not exists public.management_settings (
  id                     smallint primary key default 1 check (id = 1),
  active_menu_num        integer references public.menus(menu_num) on delete set null,
  global_discount_pct    numeric(5,2) not null default 0
    check (global_discount_pct >= 0 and global_discount_pct <= 100),
  updated_at             timestamptz not null default now()
);

/* Seed the single row */
insert into public.management_settings (id)
values (1)
on conflict (id) do nothing;

/* (Optional) Speed up FK lookups */
create index if not exists ix_management_settings_active_menu
  on public.management_settings(active_menu_num);

  /* Stations */
CREATE TABLE IF NOT EXISTS stations (
  station_id    uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  station_name  text NOT NULL CHECK (length(btrim(station_name)) > 0),
  station_type  text NOT NULL CHECK (
    station_type IN (
      'Bar',
      'Floor',
      'Kitchen',
      'Checker',
      'Hostes',
      'selector',
      'Storage',
      'Managment'
    )
  ),
  is_active     boolean NOT NULL DEFAULT TRUE,
  created_at    timestamptz NOT NULL DEFAULT now()
);

/* ------------------------------------------------------------
   Lists (supports two types: 'Tables' and 'Names')
   ------------------------------------------------------------ */
CREATE TABLE IF NOT EXISTS lists (
  list_id    uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  title      text NOT NULL CHECK (length(btrim(title)) > 0),
  list_type  text NOT NULL CHECK (list_type IN ('Tables', 'Names')),
  created_at timestamptz NOT NULL DEFAULT now()
  
);

CREATE INDEX IF NOT EXISTS ix_lists_type ON lists(list_type);
CREATE INDEX IF NOT EXISTS ix_lists_created_at ON lists(created_at);

/* ------------------------------------------------------------
   List Entries
   For 'Names' lists: use fields name, phone, note.
   For 'Tables' lists: also use num_people, start_time, end_time, minutes.
   - We keep one table and let the UI/backend decide what to populate.
   ------------------------------------------------------------ */
CREATE TABLE IF NOT EXISTS list_entries (
  entry_id    uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  list_id     uuid NOT NULL REFERENCES lists(list_id) ON DELETE CASCADE,
  arrived boolean NOT NULL DEFAULT FALSE,

  /* Common fields */
  name        text NOT NULL DEFAULT '',
  phone       text NOT NULL DEFAULT '',
  note        text NOT NULL DEFAULT '',

  /* 'Tables' extras (nullable when list is 'Names') */
  num_people  integer,
  start_time  time,
  end_time    time,
  minutes     integer,

  created_at  timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS ix_list_entries_list_id ON list_entries(list_id);


/* Junction table: which lists are attached to which stations */
CREATE TABLE IF NOT EXISTS station_lists (
  station_id uuid NOT NULL REFERENCES stations(station_id) ON DELETE CASCADE,
  list_id    uuid NOT NULL REFERENCES lists(list_id)       ON DELETE CASCADE,
  created_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (station_id, list_id)
);

CREATE INDEX IF NOT EXISTS ix_station_lists_station ON station_lists(station_id);
CREATE INDEX IF NOT EXISTS ix_station_lists_list    ON station_lists(list_id);

/* Tables: physical restaurant tables */
CREATE TABLE IF NOT EXISTS tables (
  table_id      uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  table_number  integer NOT NULL CHECK (table_number > 0),
  created_at    timestamptz NOT NULL DEFAULT now(),
  -- optional: later we can add a display name / area
  -- name         text,
  CONSTRAINT uq_tables_table_number UNIQUE (table_number)
);

/* Many-to-many between stations and tables */
CREATE TABLE IF NOT EXISTS station_tables (
  station_id uuid NOT NULL REFERENCES stations(station_id) ON DELETE CASCADE,
  table_id   uuid NOT NULL REFERENCES tables(table_id)     ON DELETE CASCADE,
  PRIMARY KEY (station_id, table_id)
);

CREATE TABLE IF NOT EXISTS table_live_info (
  table_id      uuid PRIMARY KEY REFERENCES tables(table_id) ON DELETE CASCADE,

  /* which list entry this table is currently linked to (optional) */
  list_entry_id uuid REFERENCES list_entries(entry_id) ON DELETE SET NULL,

  /* snapshot of guest info from the list entry at the moment of linking */
  guest_name    text,
  phone         text,
  note          text,
  num_people    integer,
  minimum       integer,         -- same units you use in list_entries (shekels / cents)

  created_at    timestamptz NOT NULL DEFAULT now(),
  updated_at    timestamptz NOT NULL DEFAULT now()
);

-- ===== Triggers & functions =====

-- Default/validate menu name:
-- - INSERT: if name is NULL/blank => 'Menu <menu_num>'
-- - UPDATE: forbid blank
CREATE OR REPLACE FUNCTION set_menu_defaults()
RETURNS trigger AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    IF NEW.name IS NULL OR length(btrim(NEW.name)) = 0 THEN
      NEW.name := 'Menu ' || NEW.menu_num;
    END IF;
    RETURN NEW;
  ELSE
    IF NEW.name IS NULL OR length(btrim(NEW.name)) = 0 THEN
      RAISE EXCEPTION 'menus.name cannot be blank';
    END IF;
    RETURN NEW;
  END IF;
END
$$ LANGUAGE plpgsql;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_set_menu_defaults') THEN
    CREATE TRIGGER trg_set_menu_defaults
      BEFORE INSERT OR UPDATE ON menus
      FOR EACH ROW
      EXECUTE FUNCTION set_menu_defaults();
  END IF;
END
$$;

-- After creating a menu, auto-create its root node (layer 0, parent NULL, same name)
CREATE OR REPLACE FUNCTION create_menu_root_after_insert()
RETURNS trigger AS $$
BEGIN
  BEGIN
    INSERT INTO menu_nodes (parent_id, name, is_leaf, price_cents, sort_order, layer, menu_num)
    VALUES (NULL, NEW.name, FALSE, NULL, 0, 0, NEW.menu_num);
  EXCEPTION WHEN unique_violation THEN
    -- Root already exists, ignore
    NULL;
  END;
  RETURN NEW;
END
$$ LANGUAGE plpgsql;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_create_menu_root_after_insert') THEN
    CREATE TRIGGER trg_create_menu_root_after_insert
      AFTER INSERT ON menus
      FOR EACH ROW
      EXECUTE FUNCTION create_menu_root_after_insert();
  END IF;
END
$$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_proc WHERE proname = 'set_updated_at'
  ) THEN
    CREATE OR REPLACE FUNCTION set_updated_at()
    RETURNS trigger AS $BODY$
    BEGIN
      NEW.updated_at := now();
      RETURN NEW;
    END;
    $BODY$ LANGUAGE plpgsql;
  END IF;
END;
$$;

DROP TRIGGER IF EXISTS trg_table_live_info_set_updated ON table_live_info;

CREATE TRIGGER trg_table_live_info_set_updated
BEFORE UPDATE ON table_live_info
FOR EACH ROW
EXECUTE PROCEDURE set_updated_at();

-- ===== (Optional) quick checks =====
-- -- expect 'AAA' + root:
-- -- INSERT INTO menus(name) VALUES ('AAA');
-- -- expect 'Menu <n>' + root:
-- -- INSERT INTO menus(name) VALUES (NULL);
-- -- SELECT * FROM menus ORDER BY menu_num;
-- -- SELECT menu_num, name, layer, parent_id FROM menu_nodes WHERE layer=0 ORDER BY menu_num;
