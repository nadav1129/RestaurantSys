-- ===== Core =====
SET search_path = public;
CREATE EXTENSION IF NOT EXISTS pgcrypto;  -- for gen_random_uuid()


/* ===== Tables ===== */

/* Menues */
CREATE TABLE IF NOT EXISTS menus (
  menu_num   INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name       TEXT NOT NULL CHECK (length(btrim(name)) > 0),
  created_at timestamptz NOT NULL DEFAULT now()
);

INSERT INTO menus (menu_num, name, created_at)
  VALUES (0, 'Default Menu', now())
  ON CONFLICT (menu_num) DO NOTHING;

CREATE TABLE IF NOT EXISTS menu_nodes (
  node_id     uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  parent_id   uuid NULL REFERENCES menu_nodes(node_id) ON DELETE CASCADE,
  name        TEXT NOT NULL CHECK (length(btrim(name)) > 0),
  is_leaf     boolean NOT NULL,
  price_cents int,
  sort_order  int NOT NULL DEFAULT 0,
  layer       int NOT NULL DEFAULT 0,          -- 0 = root
  menu_num    integer NOT NULL REFERENCES menus(menu_num),
  created_at  timestamptz NOT NULL DEFAULT now()
);

-- One root per menu
CREATE UNIQUE INDEX IF NOT EXISTS ux_menu_root_one_per_menu
  ON menu_nodes(menu_num)
  WHERE layer = 0 AND parent_id IS NULL;

CREATE INDEX IF NOT EXISTS ix_menu_nodes_parent      ON menu_nodes(parent_id);
CREATE INDEX IF NOT EXISTS ix_menu_nodes_menu        ON menu_nodes(menu_num);
CREATE INDEX IF NOT EXISTS ix_menu_nodes_parent_sort ON menu_nodes(parent_id, sort_order);
CREATE INDEX IF NOT EXISTS ix_menu_nodes_is_leaf     ON menu_nodes(is_leaf);

/* Ingredients */
CREATE TABLE IF NOT EXISTS ingredients (
  ingredient_id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name          text NOT NULL UNIQUE CHECK (length(btrim(name)) > 0),
  created_at    timestamptz NOT NULL DEFAULT now()
);

/* Products */
CREATE TABLE IF NOT EXISTS products (
  product_id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  menu_node_id        uuid REFERENCES menu_nodes(node_id) ON DELETE CASCADE,
  name                text NOT NULL CHECK (length(btrim(name)) > 0),
  type                text NOT NULL CHECK (length(btrim(type)) > 0),
  sold_as_bottle_only boolean NOT NULL DEFAULT FALSE,
  created_at          timestamptz NOT NULL DEFAULT now()
);

/* Products recipe line */
CREATE TABLE IF NOT EXISTS product_ingredients (
  product_id    uuid NOT NULL REFERENCES products(product_id)   ON DELETE CASCADE,
  ingredient_id uuid NOT NULL REFERENCES ingredients(ingredient_id) ON DELETE RESTRICT,
  changeable    boolean NOT NULL DEFAULT FALSE,
  is_leading    boolean NOT NULL DEFAULT FALSE,
  PRIMARY KEY (product_id, ingredient_id)
);

create table if not exists product_menu_nodes (
  product_id   uuid not null references products(product_id) on delete cascade,
  menu_node_id uuid not null references menu_nodes(node_id)  on delete cascade,
  primary key (product_id, menu_node_id)
);

create index if not exists ix_pmn_node    on product_menu_nodes(menu_node_id);
create index if not exists ix_pmn_product on product_menu_nodes(product_id);

/* Pricebook */
create table if not exists product_prices (
  product_id uuid NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
  menu_num   integer NOT NULL REFERENCES menus(menu_num) ON DELETE CASCADE,
  price      numeric(12,2) NULL,
  PRIMARY KEY (product_id, menu_num)
);

CREATE INDEX IF NOT EXISTS ix_products_node ON products(menu_node_id);          /* Products ix by id */
CREATE INDEX IF NOT EXISTS ix_products_name ON products((lower(name)));         /* Products ix by name */ 
CREATE INDEX IF NOT EXISTS ix_ingredients_name ON ingredients((lower(name)));   /* Ingredients */

/* MANAGEMENT SETTINGS (singleton) */
create table if not exists public.management_settings (
  id                     smallint primary key default 1 check (id = 1),
  active_menu_num        integer references public.menus(menu_num) on delete set null,
  global_discount_pct    numeric(5,2) not null default 0
    check (global_discount_pct >= 0 and global_discount_pct <= 100),
  updated_at             timestamptz not null default now()
);

/* Seed the single row */
insert into public.management_settings (id)
values (1)
on conflict (id) do nothing;

/* (Optional) Speed up FK lookups */
create index if not exists ix_management_settings_active_menu
  on public.management_settings(active_menu_num);

  /* Stations */
CREATE TABLE IF NOT EXISTS stations (
  station_id    uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  station_name  text NOT NULL CHECK (length(btrim(station_name)) > 0),
  station_type  text NOT NULL CHECK (
    station_type IN (
      'Bar',
      'Floor',
      'Kitchen',
      'Checker',
      'Hostes',
      'selector',
      'Storage',
      'Managment'
    )
  ),
  is_active     boolean NOT NULL DEFAULT TRUE,
  created_at    timestamptz NOT NULL DEFAULT now()
);

/* ------------------------------------------------------------
   Lists (supports two types: 'Tables' and 'Names')
   ------------------------------------------------------------ */
CREATE TABLE IF NOT EXISTS lists (
  list_id    uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  title      text NOT NULL CHECK (length(btrim(title)) > 0),
  list_type  text NOT NULL CHECK (list_type IN ('Tables', 'Names')),
  created_at timestamptz NOT NULL DEFAULT now()
  
);

CREATE INDEX IF NOT EXISTS ix_lists_type ON lists(list_type);
CREATE INDEX IF NOT EXISTS ix_lists_created_at ON lists(created_at);

/* ------------------------------------------------------------
   List Entries
   For 'Names' lists: use fields name, phone, note.
   For 'Tables' lists: also use num_people, start_time, end_time, minutes.
   - We keep one table and let the UI/backend decide what to populate.
   ------------------------------------------------------------ */
CREATE TABLE IF NOT EXISTS list_entries (
  entry_id    uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  list_id     uuid NOT NULL REFERENCES lists(list_id) ON DELETE CASCADE,
  arrived boolean NOT NULL DEFAULT FALSE,

  /* Common fields */
  name        text NOT NULL DEFAULT '',
  phone       text NOT NULL DEFAULT '',
  note        text NOT NULL DEFAULT '',

  /* 'Tables' extras (nullable when list is 'Names') */
  num_people  integer,
  start_time  time,
  end_time    time,
  minutes     integer,

  created_at  timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS ix_list_entries_list_id ON list_entries(list_id);


/* Junction table: which lists are attached to which stations */
CREATE TABLE IF NOT EXISTS station_lists (
  station_id uuid NOT NULL REFERENCES stations(station_id) ON DELETE CASCADE,
  list_id    uuid NOT NULL REFERENCES lists(list_id)       ON DELETE CASCADE,
  created_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (station_id, list_id)
);

CREATE INDEX IF NOT EXISTS ix_station_lists_station ON station_lists(station_id);
CREATE INDEX IF NOT EXISTS ix_station_lists_list    ON station_lists(list_id);

/* Tables: physical restaurant tables */
CREATE TABLE IF NOT EXISTS tables (
  table_id      uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  table_number  integer NOT NULL CHECK (table_number > 0),
  created_at    timestamptz NOT NULL DEFAULT now(),
  -- optional: later we can add a display name / area
  -- name         text,
  CONSTRAINT uq_tables_table_number UNIQUE (table_number)
);

/* Many-to-many between stations and tables */
CREATE TABLE IF NOT EXISTS station_tables (
  station_id uuid NOT NULL REFERENCES stations(station_id) ON DELETE CASCADE,
  table_id   uuid NOT NULL REFERENCES tables(table_id)     ON DELETE CASCADE,
  PRIMARY KEY (station_id, table_id)
);

CREATE TABLE IF NOT EXISTS table_live_info (
  table_id      uuid PRIMARY KEY REFERENCES tables(table_id) ON DELETE CASCADE,

  /* which list entry this table is currently linked to (optional) */
  list_entry_id uuid REFERENCES list_entries(entry_id) ON DELETE SET NULL,

  /* snapshot of guest info from the list entry at the moment of linking */
  guest_name    text,
  phone         text,
  note          text,
  num_people    integer,
  minimum       integer,         -- same units you use in list_entries (shekels / cents)

  created_at    timestamptz NOT NULL DEFAULT now(),
  updated_at    timestamptz NOT NULL DEFAULT now()
);

/* ===== Workers ===== */
CREATE TABLE IF NOT EXISTS workers (
  worker_id     uuid PRIMARY KEY DEFAULT gen_random_uuid(),

  first_name    text NOT NULL CHECK (length(btrim(first_name)) > 0),
  last_name     text NOT NULL CHECK (length(btrim(last_name)) > 0),

  /* Personal ID (teudat zehut), optional for now */
  personal_id   text,

  email         text,
  phone         text,

  position      text NOT NULL CHECK (length(btrim(position)) > 0),

  /* Salary in cents (so 10,000.00₪ = 1,000,000) */
  salary_cents  int,

  created_at    timestamptz NOT NULL DEFAULT now()
);

/* App users */
CREATE TABLE IF NOT EXISTS app_users (
  user_id        uuid PRIMARY KEY DEFAULT gen_random_uuid(),

  worker_id      uuid NOT NULL
                 REFERENCES workers(worker_id)
                 ON DELETE CASCADE,

  role           text NOT NULL CHECK (role IN ('user', 'admin')),
  passcode_hash  text NOT NULL,
  created_at     timestamptz NOT NULL DEFAULT now()
);

/* One login per worker */
CREATE UNIQUE INDEX IF NOT EXISTS ux_app_users_worker
  ON app_users (worker_id);


/* Optional: prevent two users with same name (case-insensitive) */
CREATE UNIQUE INDEX IF NOT EXISTS ux_app_users_name_ci
  ON app_users (lower(name));


/* ===== Shifts ===== */
CREATE TABLE IF NOT EXISTS shifts (
  shift_id    uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name        text,
  planned_start_at timestamptz,
  planned_end_at   timestamptz,
  started_at  timestamptz,
  ended_at    timestamptz,
  status      text NOT NULL DEFAULT 'planned'
              CHECK (status IN ('planned', 'active', 'closed', 'cancelled')),
  created_at  timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS ix_shifts_status      ON shifts(status);
CREATE INDEX IF NOT EXISTS ix_shifts_started_at  ON shifts(started_at);


/* ===== Workers per shift ===== */
CREATE TABLE IF NOT EXISTS shift_workers (
  shift_worker_id uuid PRIMARY KEY DEFAULT gen_random_uuid(),

  shift_id   uuid NOT NULL REFERENCES shifts(shift_id)   ON DELETE CASCADE,
  worker_id  uuid NOT NULL REFERENCES workers(worker_id) ON DELETE RESTRICT,

  station_id uuid REFERENCES stations(station_id) ON DELETE SET NULL,

  position_snapshot       text NOT NULL,
  salary_cents_snapshot   int,

  started_at timestamptz NOT NULL,
  ended_at   timestamptz,

  device_type text NOT NULL DEFAULT 'fixed'
              CHECK (device_type IN ('fixed', 'personal')),

  created_at  timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS ix_shift_workers_shift   ON shift_workers(shift_id);
CREATE INDEX IF NOT EXISTS ix_shift_workers_worker  ON shift_workers(worker_id);
CREATE INDEX IF NOT EXISTS ix_shift_workers_station ON shift_workers(station_id);


/* ===== Orders (per table / guest) ===== */
CREATE TABLE IF NOT EXISTS orders (
  order_id   uuid PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Which shift this order belongs to
  shift_id   uuid NOT NULL REFERENCES shifts(shift_id)   ON DELETE RESTRICT,

  -- Physical table (nullable for bar orders etc.)
  table_id   uuid REFERENCES tables(table_id) ON DELETE SET NULL,

  -- Who opened the order (device owner / station worker)
  opened_by_worker_id uuid REFERENCES workers(worker_id) ON DELETE SET NULL,

  -- Who closed/paid the order (can be same or different)
  closed_by_worker_id uuid REFERENCES workers(worker_id) ON DELETE SET NULL,

  -- Where this came from (matches your UI use-cases)
  source     text NOT NULL DEFAULT 'table'
             CHECK (source IN ('table', 'bar', 'takeaway', 'delivery', 'other')),

  status     text NOT NULL DEFAULT 'open'
             CHECK (status IN ('open', 'closed', 'cancelled')),

  opened_at  timestamptz NOT NULL DEFAULT now(),
  closed_at  timestamptz,

  /* ===== Frontend fields from OrderInfoCard / OrderPage ===== */

  guest_name   text,
  guest_phone  text,
  diners_count int CHECK (diners_count IS NULL OR diners_count >= 0),

  note         text,

  -- Table minimum for this order (in cents)
  min_spend_cents          int,

  -- “Cost”: sum of items at time of closing (in cents, no tip)
  total_before_tip_cents   int,

  -- Tip/service amount in cents (your “only10”)
  tip_cents                int,

  -- total_before_tip_cents + tip_cents
  total_cents              int,

  -- What was actually paid (handles rounding / discounts)
  paid_cents               int,

  payment_status text NOT NULL DEFAULT 'unpaid'
                 CHECK (payment_status IN ('unpaid','partial','paid')),

  created_at   timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS ix_orders_shift      ON orders(shift_id);
CREATE INDEX IF NOT EXISTS ix_orders_table      ON orders(table_id);
CREATE INDEX IF NOT EXISTS ix_orders_status     ON orders(status);
CREATE INDEX IF NOT EXISTS ix_orders_opened_at  ON orders(opened_at);


/* ===== Order items ===== */
CREATE TABLE IF NOT EXISTS order_items (
  order_item_id uuid PRIMARY KEY DEFAULT gen_random_uuid(),

  order_id   uuid NOT NULL REFERENCES orders(order_id)   ON DELETE CASCADE,
  product_id uuid NOT NULL REFERENCES products(product_id) ON DELETE RESTRICT,

  quantity   int NOT NULL CHECK (quantity > 0),

  -- Snapshot of price in cents
  price_cents  int NOT NULL,

  entered_by_worker_id uuid REFERENCES workers(worker_id) ON DELETE SET NULL,

  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS ix_order_items_order   ON order_items(order_id);
CREATE INDEX IF NOT EXISTS ix_order_items_product ON order_items(product_id);
CREATE INDEX IF NOT EXISTS ix_order_items_worker  ON order_items(entered_by_worker_id);



-- ===== Triggers & functions =====

-- Default/validate menu name:
-- - INSERT: if name is NULL/blank => 'Menu <menu_num>'
-- - UPDATE: forbid blank
CREATE OR REPLACE FUNCTION set_menu_defaults()
RETURNS trigger AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    IF NEW.name IS NULL OR length(btrim(NEW.name)) = 0 THEN
      NEW.name := 'Menu ' || NEW.menu_num;
    END IF;
    RETURN NEW;
  ELSE
    IF NEW.name IS NULL OR length(btrim(NEW.name)) = 0 THEN
      RAISE EXCEPTION 'menus.name cannot be blank';
    END IF;
    RETURN NEW;
  END IF;
END
$$ LANGUAGE plpgsql;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_set_menu_defaults') THEN
    CREATE TRIGGER trg_set_menu_defaults
      BEFORE INSERT OR UPDATE ON menus
      FOR EACH ROW
      EXECUTE FUNCTION set_menu_defaults();
  END IF;
END
$$;

-- After creating a menu, auto-create its root node (layer 0, parent NULL, same name)
CREATE OR REPLACE FUNCTION create_menu_root_after_insert()
RETURNS trigger AS $$
BEGIN
  BEGIN
    INSERT INTO menu_nodes (parent_id, name, is_leaf, price_cents, sort_order, layer, menu_num)
    VALUES (NULL, NEW.name, FALSE, NULL, 0, 0, NEW.menu_num);
  EXCEPTION WHEN unique_violation THEN
    -- Root already exists, ignore
    NULL;
  END;
  RETURN NEW;
END
$$ LANGUAGE plpgsql;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_create_menu_root_after_insert') THEN
    CREATE TRIGGER trg_create_menu_root_after_insert
      AFTER INSERT ON menus
      FOR EACH ROW
      EXECUTE FUNCTION create_menu_root_after_insert();
  END IF;
END
$$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_proc WHERE proname = 'set_updated_at'
  ) THEN
    CREATE OR REPLACE FUNCTION set_updated_at()
    RETURNS trigger AS $BODY$
    BEGIN
      NEW.updated_at := now();
      RETURN NEW;
    END;
    $BODY$ LANGUAGE plpgsql;
  END IF;
END;
$$;

DROP TRIGGER IF EXISTS trg_table_live_info_set_updated ON table_live_info;

CREATE TRIGGER trg_table_live_info_set_updated
BEFORE UPDATE ON table_live_info
FOR EACH ROW
EXECUTE PROCEDURE set_updated_at();

-- ===== (Optional) quick checks =====
-- -- expect 'AAA' + root:
-- -- INSERT INTO menus(name) VALUES ('AAA');
-- -- expect 'Menu <n>' + root:
-- -- INSERT INTO menus(name) VALUES (NULL);
-- -- SELECT * FROM menus ORDER BY menu_num;
-- -- SELECT menu_num, name, layer, parent_id FROM menu_nodes WHERE layer=0 ORDER BY menu_num;
